# 3 dimensional array
M <- array( seq(32), dim = c(4,4,2))
M
x <- list(a = 1, b = 1:3, c = 10:100)
lapply(x, FUN = length)
x
lapply(x, FUN = length)
lapply(x, FUN = sum)
x <- list(a = 1, b = 1:3, c = 10:100)
# Compare with above; a named vector, not a list
sapply(x, FUN = length)
# Compare with above; a named vector, not a list
y = sapply(x, FUN = length)
y
# Compare with above; a named vector, not a list
y[2] = sapply(x, FUN = length)
y[2]
# Compare with above; a named vector, not a list
y = sapply(x, FUN = length)
y[2]
sapply(x, FUN = length)
sapply(x, FUN = sum)
sapply(1:5,function(x) rnorm(3,x))
1:5
x = 1:5
rnorm(3,x)
rnorm(3,1:5)
rnorm(3,1:5)
13 * .4 -12 *.6
install.packages('kappalab')
require(kappalab)
## a set function
mu <- set.func(c(0:13/13,1,1))
## the Shapley value
Shapley.value(mu)
## the efficiency property should be satisfied
sum(Shapley.value(mu))
## a similar example using a Mobius.set.func object
a <- Mobius(mu)
Shapley.value(a)
## a similar example using a card.set.func object
mu <- upper.capacity(6)
Shapley.value(mu)
## the efficiency property should be satisfied
Shapley.value(mu)*6
mu
set.func(c(0:13/13,1,1))
eg = set.func(c(0,5,0,0,7,8,0,8))
Shapley.value(eg)
41/6
5/6
1/3
Shapley.value
showMethods("Shapley.value")
require(MASS)
fractions(Shapley.value(eg))
eg = set.func(c(0,5,0,0,7,8,0,8))
fractions(Shapley.value(eg))
# Class Example
class6 = set.func(c(0,5,0,0,7,8,0,8))
fractions(Shapley.value(class6))
test2 = set.func(c(0,0,0,50,0,60,80,90))
fractions(Shapley.value(test2))
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,5))
fractions(Shapley.value(assignment4.Q2.4))
# Class Example
class6 = set.func(c(0,5,0,0,7,8,0,8))
fractions(Shapley.value(class6))
fractions(Shapley.value(test2))
fractions(Shapley.value(assignment4.Q2.4))
combn(c('A','B','C'))
combn(letters[1:4], 2)
(m <- combn(10, 5, min))   # minimum value in each combination
mm <- combn(15, 6, function(x) matrix(x, 2, 3))
stopifnot(round(choose(10, 5)) == length(m),
c(2,3, round(choose(15, 6))) == dim(mm))
## Different way of encoding points:
combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)
## Assuring the identity
for(n in 1:7)
for(m in 0:n) stopifnot(is.array(cc <- combn(n, m)),
dim(cc) == c(m, choose(n, m)))
combn(c('A','B','C'),3)
x = c('A','B','C')
combn(x,3)
t(combn(LETTERS[1:3],2))
LETTERS[1:3]
x
t(combn(x,3))
t(combn(x,2))
t(combn(x,2))
t(combn(x,3))
t(combn(x,4))
t(combn(x,1))
t(combn(x))
t(combn(x,3))
x = c('A','B','C','D')
t(combn(x,4))
t(combn(LETTERS[1:4],2))
t(combn(LETTERS[1:4],3))
t(combn(LETTERS[1:4],4))
t(combn(LETTERS[1:4],3))
t(combn(LETTERS[1:4],3))
coursera.W7.6 = set.func(c(0,0,0,0,0, 70,60,60,0,0,0, 85,85,75,55, 100))
fractions(Shapley.value(coursera.W7.6))
Shapley.value(coursera.W7.6)
coursera.W7.6 = set.func(c(0,0,0,0,0, 70,60,60,0,0,0, 85,85,75,55, 0))
fractions(Shapley.value(coursera.W7.6))
coursera.W7.6 = set.func(c(0,0,0,0,0, 70,60,60,0,0,0, 85,85,75,55, 100))
fractions(Shapley.value(coursera.W7.6))
Shapley.value(coursera.W7.6
)
UN = set.func(c(0,0,0,0,1,1,0,1))
fractions(Shapley.value(UN))
# Class Example
class6 = set.func(c(0,5,0,0,7,8,0,8))
fractions(Shapley.value(class6))
# Class test 2
test2 = set.func(c(0,0,0,50,0,60,80,90))
fractions(Shapley.value(test2))
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,5))
fractions(Shapley.value(assignment4.Q2.4))
2/3
7/12
install.packages('prophet')
require(prophet)
data(nottem)
data = data('nottem')
data = datasets::('nottem')
data(bonds)
require(expsmooth)
data(bonds)
prophet(bonda)
prophet(bonds)
require(prophet)
install.packages('prophet')
require(prophet)
## Not run:
history <- data.frame(ds = seq(as.Date('2015-01-01'), as.Date('2016-01-01'), by = 'd'),
y = sin(1:366/200) + rnorm(366)/10)
m <- prophet(history)
future <- make_future_dataframe(m, periods = 365)
forecast <- predict(m, future)
plot(m, forecast)
library(prophet)
install.packages("prophet")
library("prophet", lib.loc="~/R/win-library/3.3")
library(prophet)
library(png)
img <- readPNG("Images/Decision-Tree-Best.jpg")
img <- readPNG("Images/Decision-Tree-Best.png")
require(kappalab)
require(MASS)
# Class Example
class6 = set.func(c(0,5,0,0,7,8,0,8))
fractions(Shapley.value(class6))
# 1    2    3
# 41/6  1/3  5/6
# Class test 2
test2 = set.func(c(0,0,0,50,0,60,80,90))
fractions(Shapley.value(test2))
# 1  2  3
# 5 15 70
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,5))
fractions(Shapley.value(assignment4.Q2.4))
# 1    2    3
# 11/3  1/6  7/6
coursera.W7.6 = set.func(c(0,0,0,0,0, 70,60,60,0,0,0, 85,85,75,55, 100))
fractions(Shapley.value(coursera.W7.6))
UN = set.func(c(0,0,0,0,1,1,0,1))
fractions(Shapley.value(UN))
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,5))
fractions(Shapley.value(assignment4.Q2.4))
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,7))
fractions(Shapley.value(assignment4.Q2.4))
library(ProjectTemplate)
if (!file.exists(file.path("config", "global.dcf")))
setwd("../..")
if (!exists("project.data.loaded")) {
load.project()
project.data.loaded <- TRUE
}
devtools::dev_mode(on=TRUE)
require(plotly)
z <- c(
c(8.83,8.89,8.81,8.87,8.9,8.87),
c(8.89,8.94,8.85,8.94,8.96,8.92),
c(8.84,8.9,8.82,8.92,8.93,8.91),
c(8.79,8.85,8.79,8.9,8.94,8.92),
c(8.79,8.88,8.81,8.9,8.95,8.92),
c(8.8,8.82,8.78,8.91,8.94,8.92),
c(8.75,8.78,8.77,8.91,8.95,8.92),
c(8.8,8.8,8.77,8.91,8.95,8.94),
c(8.74,8.81,8.76,8.93,8.98,8.99),
c(8.89,8.99,8.92,9.1,9.13,9.11),
c(8.97,8.97,8.91,9.09,9.11,9.11),
c(9.04,9.08,9.05,9.25,9.28,9.27),
c(9,9.01,9,9.2,9.23,9.2),
c(8.99,8.99,8.98,9.18,9.2,9.19),
c(8.93,8.97,8.97,9.18,9.2,9.18)
)
dim(z) <- c(15,6)
z2 <- z + 1
z3 <- z - 1
p <- plot_ly(showscale = FALSE) %>%
add_surface(z = ~z) %>%
add_surface(z = ~z2, opacity = 0.98) %>%
add_surface(z = ~z3, opacity = 0.98)
p
z <- c(
c(8.83,8.89,8.81,8.87,8.9,8.87),
c(8.89,8.94,8.85,8.94,8.96,8.92),
c(8.84,8.9,8.82,8.92,8.93,8.91),
c(8.79,8.85,8.79,8.9,8.94,8.92),
c(8.79,8.88,8.81,8.9,8.95,8.92),
c(8.8,8.82,8.78,8.91,8.94,8.92),
c(8.75,8.78,8.77,8.91,8.95,8.92),
c(8.8,8.8,8.77,8.91,8.95,8.94),
c(8.74,8.81,8.76,8.93,8.98,8.99),
c(8.89,8.99,8.92,9.1,9.13,9.11),
c(8.97,8.97,8.91,9.09,9.11,9.11),
c(9.04,9.08,9.05,9.25,9.28,9.27),
c(9,9.01,9,9.2,9.23,9.2),
c(8.99,8.99,8.98,9.18,9.2,9.19),
c(8.93,8.97,8.97,9.18,9.2,9.18)
)
z
z
dim(z) <- c(15,6)
z
p <- plot_ly(showscale = FALSE) %>%
add_surface(z = ~z)
p
p <- plot_ly(showscale = FALSE) %>%
add_surface(z = ~z)
p
17/20 - 7/30
x = 17/20 - 7/30
MASS::fractions(x)
require(kappalab)
require(MASS)
# Class Example
class6 = set.func(c(0,5,0,0,7,8,0,8))
fractions(Shapley.value(class6))
# 1    2    3
# 41/6  1/3  5/6
# Class test 2
test2 = set.func(c(0,0,0,50,0,60,80,90))
fractions(Shapley.value(test2))
# 1  2  3
# 5 15 70
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,7))
fractions(Shapley.value(assignment4.Q2.4))
# 1    2    3
# 11/3  1/6  7/6
fractions(Shapley.value(assignment4.Q2.4))
example = set.func(c(0,0,0,0,7,10,0,10))
fractions(Shapley.value(example))
# Class test 2
test2 = set.func(c(0,0,0,50,0,60,80,90))
fractions(Shapley.value(test2))
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,7))
fractions(Shapley.value(assignment4.Q2.4))
example = set.func(c(0,0,0,0,7,10,0,10))
fractions(Shapley.value(example))
# Solving ACF using Manual Calculation
#Sample Values
x = c(1,2,3,4,5)
x.ts = ts(x,start = 2000)
# Plot
par(mfrow=c(1,1))
plot(x.ts)
# The original values of ACF
acf(x.ts,plot = F)
# Solving ACF by using Function
acf.0 <- function(x) {
n <- length(x)
y <- x - mean(x)
sapply(1:n - 1, function(k) sum( y[1:(n-k)] * y[1:(n-k) + k] )) / sum(y * y)
}
acf.0 (x)
# The original values of ACF
acf(x.ts,plot = F)
# Visualization
par(mfrow=c(1,2))
acf(x.ts,main='ACF')
pacf(x.ts,main='PACF')
require(expsmooth)
bonds
x = bonds
x1 = lag(bonds, 1)
x
x1
x1 = lag(bonds, -1)
x1
x
x1
cor(x,x1)
x1 = lag(bonds, 1)
cor(x,x1)
x = as.vector(bonds)
x
length(x)
x1 = x[2:length(x)]
x[2:length(x)]
x = as.vector(bonds)
x1 = x[2:length(x)]
cor(x,x1)
x1 = x[1:length(x)-1]
x12 = x[2:length(x)]
x1 = x[1:length(x)-1]
x2 = x[2:length(x)]
cor(x1,x2)
acf(bonds)
par(mfrow=c(1,1))
acf(bonds)
par(mfrow=c(1,1),plot=F)
par(mfrow=c(1,1),plot=FALSE)
acf(bonds,plot = F)
cor(x1,x2)
data(rwalk) # rwalk contains a simulated random walk
plot(rwalk,type='o',ylab='Random Walk')
data(TSA::rwalk) # rwalk contains a simulated random walk
require(TSA)
data(TSA::rwalk) # rwalk contains a simulated random walk
data(rwalk) # rwalk contains a simulated random walk
plot(rwalk,type='o',ylab='Random Walk')
data(rwalk) # rwalk contains a simulated random walk
plot(rwalk,type='o',ylab='Random Walk')
rwalk
plot(robot)
data(robot)
plot(robot)
data(milk)
str(milk)
plot(milk)
library(flexdashboard)
plot(mpg)
plot(mtcars)
library(flexdashboard)
library(ggplot2)
library(dplyr)
library(plotly)
library(nycflights13)
library(forcats)
library(tidyr)
install.packages("shinydashboard")
require(kappalab)
require(MASS)
assignment4.Q2.4 = set.func(c(0,0,0,0,5,7,0,7))
fractions(Shapley.value(assignment4.Q2.4))
36954 + 14305 + 20459
A = matrix(c(0.8,1,1,.6),2,2)
A
AI = solve(A)
AD = det(A)
AI
AD
getPayoff(A)
getPayoff = function(zeroSumMatrix) {
J = matrix(1,1,nrow(zeroSumMatrix))
JT = t(J)
Payoff = as.vector(1/(J %*% AI %*% JT))
return((Payoff))
}
getStrategy = function(zeroSumMatrix) {
J = matrix(1,1,nrow(zeroSumMatrix))
JT = t(J)
x = (J %*% solve(zeroSumMatrix))[1]/(J %*% AI %*% JT)
y = (J %*% solve(zeroSumMatrix))[2]/(J %*% AI %*% JT)
return(MASS::as.fractions(c(x,y)))
}
getPayoff(A)
getStrategy(A)
J = matrix(1,1,nrow(A))
J
JT = t(J)
JT
x = (J %*% solve(zeroSumMatrix))[1]/(J %*% AI %*% JT)
x = (J %*% solve(A))[1]/(J %*% AI %*% JT)
x
solve(A))[2]
J %*% solve(A)
(J %*% solve(A))[2]
solve(A)
(J %*% solve(A))/(J %*% AI %*% JT)
J %*% AI %*% JT
(J %*% solve(A))
x = (J %*% solve(A))[1]/(J %*% AI %*% JT)
y = (J %*% solve(A))[2]/(J %*% AI %*% JT)
x
y
(36 * 60)/ 25
df <- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
ggplot(df, aes(trt, outcome)) +
geom_col()
require(ggplot2)
df <- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
ggplot(df, aes(trt, outcome)) +
geom_col()
ggplot(df, aes(trt, outcome)) +
geom_bar()
ggplot(df, aes(trt, outcome)) +
geom_bar(stat='identity')
ggplot(faithful, aes(waiting, eruptions)) +
geom_density_2d()
ggplot(faithful, aes(waiting, eruptions)) +
geom_point()
ggplot(faithful, aes(waiting, eruptions)) +
geom_density_2d()
ggplot(diamonds, aes(carat, ..count.., fill = cut)) +
geom_density(position = "fill")
ggplot(diamonds, aes(carat, ..count.., fill = cut)) +
geom_density(position = "fill", alpha = .2)
ggplot(diamonds, aes(carat, ..count.., fill = cut)) +
geom_density(position = "fill", alpha = .6)
autoplot(mpg)
x = c(2,4,4)
summary(x)
var(x)
x = c(2,4,6)
summary(x)
var(x)
var(x)/4
# K-means Clustering
# Read dataset
setwd("C:/Users/rahul/Documents/UserData/Online Training/Machine-Learning-Udemy/Part 4 - Clustering/Section 24 - K-Means Clustering")
dataset = read.csv("Mall_Customers.csv")
X = dataset[4:5]
# Using elbow method to find optimal number of clusters
set.seed(6)
wcss = vector()
for (i in 1:10) {
wcss[i] = sum(kmeans(X,i)$withinss)
}
plot(1:10, wcss, type = 'b')
# Optimal Number of cluster should be 5
# Applying K-means to Mall Dataset
set.seed(29)
kmeans = kmeans(X, 5, iter.max = 300, nstart = 10)
#Visualiing the cluster
library(cluster)
clusplot(X,
kmeans$cluster,
lines = 0,
shade = TRUE,
color = TRUE,
labels = 2,
plotchar = FALSE,
span = TRUE,
main = paste('Cluster of clients'),
xlab = 'Annual Income',
ylab = 'Spending Score'
)
plot(1:10, wcss, type = 'b')
kmeans = kmeans(X, 5, iter.max = 300, nstart = 10)
#Visualiing the cluster
library(cluster)
clusplot(X,
kmeans$cluster,
lines = 0,
shade = TRUE,
color = TRUE,
labels = 2,
plotchar = FALSE,
span = TRUE,
main = paste('Cluster of clients'),
xlab = 'Annual Income',
ylab = 'Spending Score'
)
setwd("C:/Users/rahul/Documents/UserData/Online Training/Machine-Learning-Udemy/Part 4 - Clustering/Section 25 - Hierarchical Clustering")
dataset = read.csv("Mall_Customers.csv")
dataset = read.csv("Mall_Customers.csv")
X = dataset[4:5]
X
# Using dendogram method to find optimal number of clusters
dendogram = hclust(X, 'complete')
dataset = read.csv("Mall_Customers.csv")
X = dataset[4:5]
# Using dendogram method to find optimal number of clusters
dendogram = hclust(X, 'complete')
# Using dendogram method to find optimal number of clusters
dendogram = hclust(dist(X, method = 'euclidean'), method = 'ward.D')
View(dendogram)
plot(dendogram)
plot(dendogram,
main = paste('dendogram'),
xlab = 'Customers',
ylab = 'Euclidean Distances'
)
plot(dendogram,
main = paste('dendogram'),
xlab = 'Customers',
ylab = 'Euclidean Distances'
)
y_hc = cutree(hc,5)
# Fitting Hierarchical clustering to mall dataset
hc = hclust(dist(X, method = 'euclidean'), method = 'ward.D')
y_hc = cutree(hc,5)
y_hc
clusplot(X,
y_hc,
lines = 0,
shade = TRUE,
color = TRUE,
labels = 2,
plotchar = FALSE,
span = TRUE,
main = paste('Cluster of clients'),
xlab = 'Annual Income',
ylab = 'Spending Score'
)
